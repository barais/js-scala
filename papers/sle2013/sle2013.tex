\documentclass[runningheads,a4paper]{llncs}

\usepackage{amssymb}
\setcounter{tocdepth}{3}
\usepackage{graphicx}

\usepackage[utf8]{inputenc}
\usepackage[unicode=true,hidelinks]{hyperref}

\usepackage{url}
\newcommand{\keywords}[1]{\par\addvspace\baselineskip
\noindent\keywordname\enspace\ignorespaces#1}

\include{macros}

\newcommand{\ie}{\emph{i.e.}}
\newcommand{\eg}{\emph{e.g.}}
\newcommand{\cf}{\emph{cf.~}}
\newcommand{\etal}{\emph{et al.~}}
\newcommand{\etc}{\emph{etc.}}
\newcommand{\aka}{\emph{a.k.a.}}


\begin{document}

\mainmatter

\title{Using Path-Dependent Types to Build Safe JavaScript Foreign Function Interfaces}
%\titlerunning{Dependent Types Rock}

\author{Julien Richard-Foy \and Olivier Barais\and Jean-Marc Jézéquel}
\authorrunning{Julien Richard-Foy \emph{et. al.}}

\institute{IRISA, Université de Rennes 1, France. \texttt{\{first\}.\{last\}@irisa.fr}}

%\toctitle{Lecture Notes in Computer Science}
%\tocauthor{Authors' Instructions}
\maketitle


\begin{abstract}
Several programming languages can target JavaScript as a back-end, giving developers programming
language features that are absent from JavaScript, such as static typing. However, the Web browser
APIs, which are needed to interact with a Web page, are designed for JavaScript, making it
challenging to expose them in a statically typed language. Indeed, existing statically typed
languages exposing Web browser APIs either break type safety or give developers less control than if
they were using JavaScript. This article shows how to expose Web browser APIs in Scala in a type
safe way while keeping the same level of control as with native APIs by using path-dependent types
and functional dependencies. We validate this approach in designing safe and concise foreign
function interfaces between Scala and JavaScript for DOM events handling and DOM manipulation. We
compared this approach to common frameworks such as GWT, Fay, Kotlin, Dart and SharpKit.
\keywords{Path-Dependent Types, JavaScript, Scala, Foreign Function Interface}
\end{abstract}


\section{Introduction}

Web applications are attractive because they require no installation or deployment step on clients
and enable large scale collaborative experiences. Besides, now they can be executed
efficiently~\cite{Gal:2009:TJT:1542476.1542528} on top of modern web-browsers. However, writing
large Web applications is known to be
difficult~\cite{Mikkonen08_SpaghettiJs,Preciado05_RIAMethodologyNecessity}. One challenge comes from
the fact that the JavaScript programming language -- which is currently the only action language
natively supported by almost all Web clients -- lacks of constructs making large code bases
maintainable (\eg static typing, first-class modules).

One solution consists in considering JavaScript as an assembly language\footnote{\cf
\href{http://asmjs.org/}{http://asmjs.org/}} and generating JavaScript from compilers of
full-featured and cutting-edge programming languages. Incidentally, an increasing number of
programming languages or compiler back-ends can generate JavaScript code (\eg
Java/GWT~\cite{Chaganti07_GWT},
SharpKit\footnote{\href{http://sharpkit.net}{http://sharpkit.net}}, Dart~\cite{Griffith11_Dart},
Kotlin\footnote{\href{http://kotlin.jetbrains.org/}{http://kotlin.jetbrains.org/}},
ClojureScript~\cite{McGranaghan11_ClojureScript},
Fay\footnote{\href{http://fay-lang.org/}{http://fay-lang.org/}}, Haxe~\cite{Cannasse08_HaXe},
Opa\footnote{\href{http://opalang.org/}{http://opalang.org/}}). However, compiling to JavaScript is
not enough. Developers also need the Web browser programming environment: they need to interact with
the Web page, to build DOM fragments, to listen to user events, \etc. A Foreign Function
Interface (FFI) mechanism could be used to make browser’s APIs available to the developers. However,
JavaScript APIs are not statically typed and make a heavy use of overloading, making them hard to
expose in a statically typed language.

Indeed, existing statically typed languages compiling to JavaScript often expose weaker types than
they should. For instance, the function \code{createElement} is polymorphic in its return type: it
can return a \code{DivElement} as well as an \code{InputElement}, among others, but the Dart, Fay,
SharpKit and Kotlin APIs return the super-type of all the possible values, namely the \code{Element}
type. As a consequence, developers need to explicitly down-cast the value they get, which is a
tedious and error prone task.

Some other languages try to workaround this problem by using overloading instead of polymorphism.
For instance, HaXe provides functions \code{createDivElement}, \code{createInputElement}, which
return a \code{DivElement} and an \code{InputElement}, respectively. Besides requiring a higher
effort to implement, this solution also reduces the control level of users: by being statically
resolved, the element type can not anymore be passed as a parameter.

It turns out that most of the existing statically typed languages compiling to JavaScript either
loose control or loose type safety when they expose Web browser’s APIs. How to give developers the
same level of control as if they were using the native Web APIs, but in a statically typed and
convenient way?

In this paper we present several ways to integrate Web browser’s APIs as statically typed APIs that
are safe and give developers the same control level as if they were using the native APIs. We
achieve this by using advanced features of type systems like dependent types and functional
dependencies. We validate this approach in designing safe FFI between Scala and JavaScript for DOM
events handling and DOM manipulation. We compared this approach to common frameworks such as GWT,
Fay, Kotlin, Dart and SharpKit.


The outline of this paper is the following.
Section~\ref{sec:background} presents several motivating example and gives a background about
path-dependent type.
Section~\ref{sec:jsscala} presents %...
Section~\ref{sec:evaluation} validates our ideas through the design of FFI for DOM events handling
and DOM manipulation in Scala and compare these FFIs w.r.t. the existing FFIs for these features
within frameworks such as GWT, Fay, Kotlin, Dart and SharpKit.
Section~\ref{sec:related} discusses related work, Section~\ref{sec:conclusion} concludes this paper
and highlights  future work. 


\section{Background Material}

\subsection{Foreign Function Interface}

A FFI is a mechanism that allows a programmer to link one programming language program to programs
written in another language. Such mechanisms exist in lots of languages: Ada, Java, Haskell, Lisp or
GWT. Despite the name, FFIs are not necessarily restricted to function calls; many FFIs permit
method calls on objects; and some even permit migration of non-trivial datatypes and/or objects
across the language boundary. Nevertheless, the challenging tasks come when you want to: (i) manage
shared garbage collection policies, (ii) handle the conversion of complex datatype to map from one
environment to another and (iii) handle the design of safe foreign function interfaces regarding
typing system constraints that can differ from one environment to another. This last issue is the
one which is targeted in this paper for the design of FFI between a statically typed language such
as Scala and a dynamically typed language such as JavaScript.


\subsection{}

A type system provides us a near mathematical proof that programs that compile successfully obey a
set of rules and restrictions and, as such, are bug-free in that respect. For example, after
compiling a Java program, developer knows that the it will not do a division of a number with a
string and that, if our method foo receives an integer as argument, it will not be called anywhere
with an argument of any type other than an integer.

Among all the type theory,  dependent types is a term that describes using values as types, the type
depends on a value. This means you can encode some properties of an object in its type. Once you do
that, it allows a type checker (a compiler) to verify that the object (type) is used in a suitable
way. Scala defines a concept of path-dependent type. Scala has the concept of abstract types: types
that, just like abstract methods, must be defined by subclasses. Objects can have a type as members.
As the term path-dependent type says, the type depends on the path: in general, different paths give
rise to different types. 

%TODO Show a simple example from the web. 

More advanced type systems, such as the one featured in Scala, increase our confidence in the
systems we develop and help us reduce the number of bugs before deployment. Path-dependent types and
dependent method types play a crucial role for attempts to encode information into types that is
typically only known at runtime. It is important to note that these important validations don't
require extra effort from developers -– no need to manually write tests or to run third-party tools
–- and have no runtime performance impact, which is always a key concern when developing online
systems. The goal of this paper is to highlight the benefits of putting the Scala type system for
building efficient web applications.



%TODO do the link and describe the problem. 
Why is it difficult to type Web browser’s APIs?

\subsection{DOM Creation}

\begin{lstlisting}[language=JavaScript]
var div = document.createElement('div');
var input = document.createElement('input');
\end{lstlisting}

\code{div} has type \code{DivElement} while \code{input} has type \code{InputElement}. These types
have different methods. As stated in the introduction, most statically typed language have an API
that returns an \code{Element}, which is the least upper bound of the possible types returned by
\code{createElement}, forcing users to explicitly down-cast the result to the expected type, thus
loosing type safety.

Alternatively, some languages use overloading.

Consider the following function creating an element and giving it a class name:

\begin{lstlisting}[language=JavaScript]
var create = function (elementType, className) {
  val el = document.createElement(elementType);
  el.className = className;
  return el
};
create('input', 'field').focus();
create('img', 'figure').src = 'http://google.com/logo.png';
\end{lstlisting}

How to type check the above code? The problem is that the return type of the \code{create} function
depends on its first parameter.

Note that a possible solution in Java could be the following:

\begin{lstlisting}[language=Java]
class ElementName<E> {}
ElementName<InputElement> Input = new ElementName<InputElement>();
ElementName<ImageElement> Img = new ElementName<ImageElement>();

<E> E create(ElementName<E> type, String className) {
  ...
}

create(Input, "field").focus();
create(Img, "figure").setSrc("http://google.com/logo.png");
\end{lstlisting}

However, the type parameter \code{E} has to be filled at use-site. If the compiler can infer it,
that’s fine.

\subsection{DOM Events}

A similar issue applies to the DOM events API.

\begin{lstlisting}[language=Java]
class EventName<E> {}
EventName<ClickEvent> Click = new EventName<ClickEvent>();

void on(EventName<E> type, Callback<E> callback) { ... }

Callback<ClickEvent> incrementCounter = new Callback<ClickEvent>() {
  @Override
  void execute(ClickEvent event) {
    ...
  }
}

on(Click, incrementCounter);

<E> Stream<E> stream(EventName<E> type) {
  return new Stream<E>() {
    @Override
    void subscribe(Observer<E> observer) {
      on(type, new Callback<E> {
        @Override
        void execute(E event) {
          observer.publish(event);
        }
      });
    }
  }
}

\end{lstlisting}

Again, the type parameter \code{E} has to be filled at use-site.

\subsection{Selectors}

The problem with selectors is slightly different.

\begin{lstlisting}[language=JavaScript]
var input = document.querySelector('input');
var el = document.querySelector('#content');
\end{lstlisting}

\code{input} can not have another type than \code{InputElement}, but \code{el} can be an element of
any type (depending on which element has the id \code{content}). Return type can not \emph{always}
be inferred from the parameters. In this case, down-casting is impossible to avoid, but how to make
it optional, and how to make it less risky?

We want to be able to write the following code:

\begin{lstlisting}
val input = document.find(Input) // input has type InputElement
val el = document.find("#content") // el has type Element
val img = document.find[Img](".figure") // note that the type Img is explicitly applied in this case
                                        // but was automatically inferred in previous cases
val error = document.find[Int]("div") // Does not compile: querySelector can not return a number
\end{lstlisting}



\subsection{dependent types}

\section{Lightweight Modular Staging}

\section{Contribution}

\subsection{Events}

Path-dependent types to abstract over an event name and its data type.

\subsection{Selectors}

Less type annotations on DOM queries, less chance to write nonsense casts

\subsection{DOM}

Path-dependent types to abstract over an element name and its data type.

\section{Evaluation}

\subsection{Events}

Other languages either provide loose information about the data type of the listened event (Dart) or
give no way to abstract over an event (GWT, Kotlin).

\section{Conclusion and Perspectives}


\bibliographystyle{plain}
\bibliography{biblio}

\end{document}

